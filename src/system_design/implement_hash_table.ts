/* """
Implementing our Own Hash Table with Separate Chaining in Python

Every data structure has its own special characteristics for example a BST is used when quick
searching of an element (in log(n)) is required. A heap or a priority queue is used when the
minimum or maximum element needs to be fetched in constant time. Similarly a hash table is used
to fetch, add and remove an element in constant time. It is necessary for anyone to be clear with
the working of a hash table before moving on to the implementation aspect. So here is a brief
background on the working of hash table and also it should be noted that we will be using Hash
Map and Hash Table terminology interchangeably though in Java HashTables are thread safe while
HashMaps are not.

The code we are going to implement is available at Link 1 and Link2

But it is strongly recommended that one must read this blog completely and try and decipher the
nitty gritty of what goes into implementing a hash map and then try to write the code yourself.

------------------------------------------------
Background
------------------------------------------------

Every hash-table stores data in the form of (key, value) combination. Interestingly every key is
unique in a Hash Table but values can repeat which means values can be same for different keys
present in it. Now as we observe in an array to fetch a value we provide the position/index
corresponding to the value in that array. In a Hash Table, instead of an index we use a key to
fetch the value corresponding to that key. Now the entire process is described below

Every time a key is generated. The key is passed to a hash function. Every hash function has two
parts a Hash code and a Compressor.

Hash code is an Integer number (random or nonrandom). In Java every Object has its own hash code.
We will use the hash code generated by JVM in our hash function and to compress the hash code we
modulo(%) the hash code by size of the hash table. So modulo operator is compressor in our
implementation.

The entire process ensures that for any key, we get an integer position within the size of the
Hash Table to insert the corresponding value.

So the process is simple, user gives a (key, value) pair set as input and based on the value
generated by hash function an index is generated to where the value corresponding to the
particular key is stored. So whenever we need to fetch a value corresponding to a key that is
just O(1).

This picture stops being so rosy and perfect when the concept of hash collision is introduced.
Imagine for different key values same block of hash table is allocated now where do the
previously stored values corresponding to some other previous key go. We certainly can't replace
it .That will be disastrous! To resolve this issue we will use Separate Chaining Technique,
Please note there are other open addressing techniques like double hashing and linear probing
whose efficiency is almost same as to that of separate chaining and you can read more about them
at Link 1 Link 2 Link3

Now what we do is make a linked list corresponding to the particular bucket of the Hash Table,
to accommodate all the values corresponding to different keys who map to the same bucket.

                ----
                 0   ---> 1->2->3
                ----
                 1   ---> 1
                ----
hashKey(key)==>  2   ---> 1->2
                ----
                 3   ---> 1->2
                ----
                 4   ---> 1->2->3
                ----
                 5   ---> 1->2
                ----

Now there may be a scenario that all the keys get mapped to the same bucket and we have a linked
list of n(size of hash table) size from one single bucket, with all the other buckets empty and
this is the worst case where a hash table acts a linked list and searching is O(n).So what do we
do ?

==Load Factor==

If n be the total number of buckets we decided to fill initially say 10 and let's say 7 of them
got filled now, so the load factor is 7/10=0.7.

In our implementation whenever we add a key value pair to the Hash Table we check the load factor
if it is greater than 0.7 we double the size of our hash table.

------------------------------------------------
Implementation
------------------------------------------------

Hash Node Data Type
We will try to make a generic map without putting any restrictions on the data type of the key
and the value. Also every hash node needs to know the next node it is pointing to in the linked
list so a next pointer is also required.

The functions we plan to keep in our hash map are

get(K key) : returns the value corresponding to the key if the key is present in HT (Hast Table)
getSize() : return the size of the HT
add() : adds new valid key, value pair to the HT, if already present updates the value
remove() : removes the key, value pair
isEmpty() : returns true if size is zero

Every Hash Map must have an array list/linked list with an initial size and a bucket size which
gets increased by unity every time a key, value pair is added and decreased by unity every time a
node is deleted

- - - - - - - - - - - - - - - - - - - - - - - - - - -
ArrayList<HashNode<K, V>> bucket = new ArrayList<>()
- - - - - - - - - - - - - - - - - - - - - - - - - - -

A Helper Function is implemented to get the index of the key, to avoid redundancy in other
functions like get, add and remove. This function uses the in built java function to generate a
hash code and we compress the hash code by the size of the HT so that the index is within the
range of the size of the HT

==get()==
The get function just takes a key as an input and returns the corresponding value if the key is
present in the table otherwise returns null. Steps are:

1. Retrieve the input key to find the index in the HT
2. Traverse the linked list corresponding to the HT, if you find the value then return it else
 if you fully traverse the list without returning it means the value is not present in the table
 and can't be fetched so return null

==remove()==
1. Fetch the index corresponding to the input key using the helper function
2. The traversal of linked list similar like in get() but what is special here is that one needs to
 remove the key along with finding it and two cases arise
3. If the key to be removed is present at the head of the linked list
4. If the key to be removed is not present at head but somewhere else

==add()==
Now to the most interesting and challenging function of this entire implementation. It is
interesting because we need to dynamically increase the size of our list when load factor is
above the value we specified.

1.  Just like remove steps till traversal and adding and two cases (addition at head spot or
    non-head spot) remain the same.
2.  Towards the end if load factor is greater than 0.7
3.  We double the size of the array list and then recursively call add function on existing keys
    because in our case hash value generated uses the size of the array to compress the hash code
    we use ,so we need to fetch new indices for the existing keys. This is very important to
    understand please re read this paragraph till you get a hang of what is happening in the add
    function.

""" */


class HashNode<T> {
    key: string;
    value: T;
    next: HashNode<T> | null;

    constructor(key: string, value: T) {
        this.key = key;
        this.value = value;
        this.next = null;
    }
}

export class Map<T> {
    numBuckets: number;
    bucketArray: Array<HashNode<T> | null>;
    size: number;

    constructor() {
        this.numBuckets = 10;
        this.bucketArray = new Array(this.numBuckets).fill(null);
        this.size = 0;
    }

    isEmpty(): boolean {
        return this.size === 0;
    }

    getBucketIndex(key: string): number {
        const hashCode = this.hash(key);
        const index = hashCode % this.numBuckets;
        return index;
    }

    remove(key: string): T | null {
        const bucketIndex = this.getBucketIndex(key);
        let head = this.bucketArray[bucketIndex];
        let prev = null;

        while (head !== null) {
            if (head.key === key) {
                break;
            }

            prev = head;
            head = head.next;
        }

        if (head === null) {
            return null;
        }

        this.size--;

        if (prev !== null) {
            prev.next = head.next;
        } else {
            this.bucketArray[bucketIndex] = head.next;
        }

        return head.value;
    }

    get(key: string): T | null {
        const bucketIndex = this.getBucketIndex(key);
        let head = this.bucketArray[bucketIndex];

        while (head !== null) {
            if (head.key === key) {
                return head.value;
            }

            head = head.next;
        }

        return null;
    }

    add(key: string, value: T): void {
        const bucketIndex = this.getBucketIndex(key);
        let head = this.bucketArray[bucketIndex];

        while (head !== null) {
            if (head.key === key) {
                head.value = value;
                return;
            }

            head = head.next;
        }

        this.size++;
        head = this.bucketArray[bucketIndex];
        const newNode = new HashNode(key, value);
        newNode.next = head;
        this.bucketArray[bucketIndex] = newNode;

        if ((1.0 * this.size) / this.numBuckets >= 0.7) {
            const temp = this.bucketArray;
            this.numBuckets = 2 * this.numBuckets;
            this.bucketArray = new Array(this.numBuckets).fill(null);
            this.size = 0;

            for (const headNode of temp) {
                let current = headNode;
                while (current !== null) {
                    this.add(current.key, current.value);
                    current = current.next!;
                }
            }
        }
    }

    private hash(key: string): number {
        // Simple hash function for demonstration purposes
        let hash = 0;
        for (let i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash;
    }
}

if (require.main === module) {
    const _map = new Map<number>();
    _map.add("this", 1);
    _map.add("coder", 2);
    _map.add("this", 4);
    _map.add("hi", 5);

    console.log(_map.get("coder"));
    console.log(_map.remove("this"));
    console.log(_map.remove("this"));
    console.log(_map.isEmpty());
}
